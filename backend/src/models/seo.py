"""SEO metadata model for article optimization."""

from datetime import datetime
from typing import TYPE_CHECKING

from sqlalchemy import (
    ARRAY,
    CheckConstraint,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.models.base import Base, TimestampMixin

if TYPE_CHECKING:
    from src.models.article import Article


class SEOMetadata(Base, TimestampMixin):
    """SEO metadata for articles generated by Claude Messages API.

    Stores comprehensive SEO analysis including:
    - Meta title and description
    - Focus and supporting keywords
    - Keyword density analysis
    - Readability scoring
    - Optimization recommendations

    One-to-one relationship with Article.
    """

    __tablename__ = "seo_metadata"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)

    # Foreign key to articles (1:1 relationship)
    article_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("articles.id", ondelete="CASCADE"),
        unique=True,
        nullable=False,
        index=True,
        comment="Reference to article (1:1 relationship)",
    )

    # Core SEO fields
    meta_title: Mapped[str] = mapped_column(
        String(60),
        nullable=False,
        comment="SEO meta title (50-60 chars)",
    )

    meta_description: Mapped[str] = mapped_column(
        String(160),
        nullable=False,
        comment="SEO meta description (150-160 chars)",
    )

    focus_keyword: Mapped[str] = mapped_column(
        String(100),
        nullable=False,
        index=True,
        comment="Primary focus keyword for SEO",
    )

    # Keyword arrays
    primary_keywords: Mapped[list[str] | None] = mapped_column(
        ARRAY(String(100)),
        nullable=True,
        comment="3-5 primary keywords",
    )

    secondary_keywords: Mapped[list[str] | None] = mapped_column(
        ARRAY(String(100)),
        nullable=True,
        comment="5-10 secondary keywords",
    )

    # Keyword density analysis (JSONB: {keyword: {count: int, density: float}})
    keyword_density: Mapped[dict | None] = mapped_column(
        JSONB,
        nullable=True,
        default=dict,
        comment="Keyword -> {count, density} mapping",
    )

    # Scoring
    readability_score: Mapped[float | None] = mapped_column(
        Float,
        nullable=True,
        comment="Flesch Reading Ease score (0-100)",
    )

    seo_score: Mapped[float | None] = mapped_column(
        Float,
        nullable=True,
        index=True,
        comment="Overall SEO score (0-100)",
    )

    # Recommendations (JSONB array of strings)
    optimization_recommendations: Mapped[list | None] = mapped_column(
        JSONB,
        nullable=True,
        default=list,
        comment="Array of optimization suggestions",
    )

    # Manual overrides tracking
    manual_overrides: Mapped[dict | None] = mapped_column(
        JSONB,
        nullable=True,
        default=dict,
        comment="User-edited fields tracking",
    )

    # Generation metadata
    generated_by: Mapped[str | None] = mapped_column(
        String(50),
        nullable=True,
        default="claude-3-5-haiku-20241022",
        comment="AI model used for generation",
    )

    generation_cost: Mapped[float | None] = mapped_column(
        Float,
        nullable=True,
        comment="Cost in USD for SEO analysis",
    )

    generation_tokens: Mapped[int | None] = mapped_column(
        Integer,
        nullable=True,
        comment="Total tokens used (input + output)",
    )

    error_message: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
        comment="Error message if analysis failed",
    )

    # Relationships
    article: Mapped["Article"] = relationship(
        "Article",
        back_populates="seo_metadata",
        foreign_keys=[article_id],
    )

    # Constraints (enforced at database level, documented here)
    __table_args__ = (
        CheckConstraint(
            "char_length(meta_title) >= 50 AND char_length(meta_title) <= 60",
            name="meta_title_length_check",
        ),
        CheckConstraint(
            "char_length(meta_description) >= 150 AND char_length(meta_description) <= 160",
            name="meta_description_length_check",
        ),
        CheckConstraint(
            "array_length(primary_keywords, 1) >= 3 AND array_length(primary_keywords, 1) <= 5",
            name="primary_keywords_count_check",
        ),
        CheckConstraint(
            "array_length(secondary_keywords, 1) >= 5 AND array_length(secondary_keywords, 1) <= 10",
            name="secondary_keywords_count_check",
        ),
        CheckConstraint(
            "readability_score IS NULL OR (readability_score >= 0 AND readability_score <= 100)",
            name="readability_score_range_check",
        ),
        CheckConstraint(
            "seo_score IS NULL OR (seo_score >= 0 AND seo_score <= 100)",
            name="seo_score_range_check",
        ),
    )

    def __repr__(self) -> str:
        """String representation."""
        return (
            f"<SEOMetadata(id={self.id}, article_id={self.article_id}, "
            f"focus_keyword='{self.focus_keyword}', seo_score={self.seo_score})>"
        )

    @property
    def is_manually_edited(self) -> bool:
        """Check if any fields have been manually overridden."""
        return bool(self.manual_overrides)

    @property
    def total_keywords(self) -> int:
        """Count total keywords (primary + secondary)."""
        primary_count = len(self.primary_keywords) if self.primary_keywords else 0
        secondary_count = len(self.secondary_keywords) if self.secondary_keywords else 0
        return primary_count + secondary_count

    @property
    def is_complete(self) -> bool:
        """Check if SEO metadata has all required fields."""
        return all([
            self.meta_title,
            self.meta_description,
            self.focus_keyword,
            self.primary_keywords and len(self.primary_keywords) >= 3,
            self.secondary_keywords and len(self.secondary_keywords) >= 5,
            self.readability_score is not None,
            self.seo_score is not None,
        ])

    def get_keyword_density(self, keyword: str) -> dict[str, float] | None:
        """Get density data for a specific keyword.

        Args:
            keyword: The keyword to look up

        Returns:
            Dict with 'count' and 'density' keys, or None if not found
        """
        if not self.keyword_density:
            return None
        return self.keyword_density.get(keyword)

    def add_manual_override(self, field: str, old_value: str, new_value: str) -> None:
        """Track manual override of an AI-generated field.

        Args:
            field: Name of the field that was overridden
            old_value: Original AI-generated value
            new_value: New user-provided value
        """
        if not self.manual_overrides:
            self.manual_overrides = {}

        self.manual_overrides[field] = {
            "old_value": old_value,
            "new_value": new_value,
            "overridden_at": datetime.utcnow().isoformat(),
        }
